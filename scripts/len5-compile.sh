#!/bin/bash

####################
# ----- INFO ----- #
####################

# Compile LEN5 source files and optionally simulated the requested file.

#############################
# ----- CONFIGURATION ----- #
#############################

# PARAMETERS
# ----------

# Paths
LEN5_ROOT_DIR="$(realpath $(dirname $0)/..)"
SIM_DIR="$LEN5_ROOT_DIR/private/build"
LOG_FILE="$SIM_DIR/len5-compile.log"
TB_VLOG_OPT_FILE="$LEN5_ROOT_DIR/config/tb-list"

# Command line arguments
PRINT_CMD_LINE=0
CMD_LINE=$@

# Remote execution
FORCE_LOCAL_EXEC=0
REMOTE_EXEC=0
REMOTE_USER=""
REMOTE_PORT=10033 # vlsi21
REMOTE_HOST=vlsiwall.polito.it
REMOTE_ROOT_DIR="~/sim/len5"
SSH_KEY=~/.ssh/vlsi_rsa
SSH_OPT="-p $REMOTE_PORT -i $SSH_KEY"
RSYNC_OPT="--relative -rtl --del"

# Compilation options
COMPILE_ONLY=0
COMPILE_OPT_FILE=$SIM_DIR/compile.f
CUSTOM_SRC=0
BUILD_TARGET=source-files
VLIB_PATH=$SIM_DIR/work

# Simulation options
TOP_MODULE_FILE=$LEN5_ROOT_DIR/tb/tb_with_l2cemu.sv
SIM_MACRO="$SIM_DIR/sim.do"
SIM_WAVE_ZOOM=1000 # ns
SIM_OPT="-sv_seed random" # default simulator options
POST_SIM_SCRIPT=""
VSIM_GUI=0
VSIM_DISABLE_OPT=1
NUM_CYCLES=1000

# Compile and simulate script
HEADER_MSG="# Auto-generated by $0 -- $(date)"
CMD_LINE_MSG="# command line: $(basename $0) $@"
RUN_SCRIPT=""

####################################
# ----- FUNCTION DEFINITIONS ----- #
####################################

# Print usage message
print_usage() {
    [ ! "$1" = "" ] && { printf -- "\nERROR: %s\n\n" "$1" 1>&2; }
    printf -- "USAGE: $0 [OPTIONS] [SRC_DIR] [TOP_MODULE_FILE] [SIM_ARGS]\n"
    printf -- "OPTIONS:\n"
    printf -- "\n"
    printf -- "General:\n"
    printf -- "-h:      print this message and exit.\n"
    printf -- "-l:      print command line arguments and exit.\n"
    printf -- "-s DIR:  use DIR as simulation working directory.\n"
    printf -- "-g FILE: auto-generate compile-and-run script FILE.\n"
    printf -- "-r STR:  compile [and simulate] on a remote server.\n"
    printf -- "-L:      force local execution (overrides '-r').\n"
    printf -- "-S STR:  set SSH options to 'STR' Default: '%s'.\n" "$SSH_OPT"
    printf -- "\n"
    printf -- "Compilation:\n"
    printf -- "-c:      don't start simulation (compile only).\n"
    printf -- "-b TGT:  build target TGT. Default: '%s'.\n" $BUILD_TARGET
    printf -- "-t:      shortcut for '-b tb' (also compile testbench files).\n"
    printf -- "-d:      clean build directory (shortcut for '-cb clean').\n"
    printf -- "-n:      compile dry run (pass '-n' to make).\n"
    printf -- "-f OPTS: add OPTS to 'vlog' command-line arguments.\n"
    printf -- "-w LIB:  use custom library path LIB.\n"
    printf -- "\n"
    printf -- "Simulation (ignored with '-c'):\n"
    printf -- "-m FILE: append '+MEM_FILE=FILE' to vsim command line.\n"
    printf -- "-W FILE: load waveforms from FILE.\n"
    printf -- "-N NUM:  simulate NUM cycles; infinite if 0. Default: %d.\n" $NUM_CYCLES
    printf -- "-x:      launch simulation with GUI (ignores '-o').\n"
    printf -- "-o:      remove '-voptargs=+acc' from simulation options.\n"
    printf -- "-p FILE: pass '-do FILE' to the simulator AFTER the 'run' command.\n"
}

# Log message
function log() {
    if [ $# -eq 0 ]; then
        printf -- "\n"
    else
        printf -- "### INFO > " | tee /dev/tty >> $LOG_FILE
        printf -- "$@" | tee /dev/tty >> $LOG_FILE
        printf -- "\n" | tee /dev/tty >> $LOG_FILE
    fi
}

# Print error message and terminate with error
function err() {
    printf -- "\n!!! ERR  > " | tee /dev/tty >&2 >> $LOG_FILE
    printf -- "$@" | tee /dev/tty >&2 >> $LOG_FILE
    printf -- "\n" | tee /dev/tty >&2 >> $LOG_FILE
    exit 1
}

# Run and log command
function run_and_log() {
    local CMD="$@"
    log "Executing '$CMD'..."
    printf -- "====================== [%s] BEGIN ======================\n" "$1"
    set -o pipefail
    $CMD |& tee /dev/tty | sed "s/^/[$1] /" >> $LOG_FILE
    RET=$?
    set +o pipefail
    printf -- "======================= [%s] END =======================\n" "$1"
    return $RET
}

# Command to simulation script
function to_run_script() {
    local CMD="$@"
    [ ! "$RUN_SCRIPT" = "" ] && echo $CMD >> $RUN_SCRIPT
}

# Send commands to remote host
function remote_and_log() {
    local CMD="$@"
    log "Executing on remote host: $CMD..."
    printf -- "===================== REMOTE BEGIN =====================\n"
    set -o pipefail
    ssh -t $SSH_OPT $REMOTE_USER@$REMOTE_HOST "$CMD" |& tee /dev/tty | sed "s/^/[REMOTE] /" >> $LOG_FILE
    RET=$?
    set +o pipefail
    printf -- "====================== REMOTE END ======================\n"
    return $RET
}

# Clean up and exit
function clean_up() {
    log "Cleaning up..."
    [ ! "$RUN_SCRIPT" = "" ] && chmod +x $RUN_SCRIPT
    if [ $HOST_NAME = "ghostpro" ]; then
        source $INIT_SCRIPT -q
    fi
    log "ALL DONE!"
}

####################################
# ----- COMMAND LINE OPTIONS ----- #
####################################

# Parse command line options
# --------------------------
while getopts ':hls:g:rLS:cb:tdnf:w:im:W:N:xop:' opt; do
    case $opt in
        h) # Print usage message
            print_usage
            exit 0
            ;;
        l) # print command line arguments
            PRINT_CMD_LINE=1
            ;;
        s) # Change simulation orking directory
            SIM_DIR="$OPTARG"
            ;;
        g) # auto-generate script
            RUN_SCRIPT="$OPTARG"
            rm -f $RUN_SCRIPT
            touch $RUN_SCRIPT
            ;;
        r) # compile and run on remote server
            REMOTE_EXEC=1
            ;;
        L) # force local execution
            FORCE_LOCAL_EXEC=1
            ;;
        S) # Set rsync options
            SSH_OPT="$OPTARG"
            ;;
        c) # Only compile the source files
            COMPILE_ONLY=1
            ;;
        b) # Select build target
            BUILD_TARGET=$OPTARG
            ;;
        t) # shortcut for '-b tb' (also compile testbench files)
            BUILD_TARGET="tb"
            ;;
        d) # Clean build directory
            BUILD_TARGET=clean
            COMPILE_ONLY=1
            ;;
        n) # compile dry run (pass '-n' to make)
            MAKE_OPT="$MAKE_OPT -n"
            ;;
        f) # add compilation options to 'vlog' command line
            VLOG_ARGS="$VLOG_ARGS $OPTARG"
            ;;
        w) # Use custom library
            VLIB_PATH=$OPTARG
            ;;
        m) # append '+MEM_FILE=FILE' to vsim command line
            MEM_FILE=$OPTARG
            ;;
        W) # add simulation options
            WAVE_FILE="$OPTARG"
            ;;
        N) # set the number of simulation cycles
            NUM_CYCLES=$OPTARG
            ;;
        x) # Launch simulation with GUI
            VSIM_GUI=1
            ;;
        o) # Remove -voptargs=+acc from simulation options
            VSIM_DISABLE_OPT=0
            ;;
        p) # pass '-do FILE' to the simulator AFTER the 'run' command
            POST_SIM_SCRIPT="$OPTARG"
            ;;
        *) # Invalid option
            print_usage "invalid option"
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

####################################
# ----- COMPILE AND SIMULATE ----- #
####################################

# Initialization
# --------------

# Initialize simulation directory
mkdir -p $SIM_DIR

# Initialize compilation log
> $LOG_FILE

# Print welcome message
log "    [This is '%s' on '%s']" "$(basename $0)" "$(uname -n)"
log
if [ $PRINT_CMD_LINE -ne 0 ]; then
    log "arguments:"
    for arg in $CMD_LINE; do
        log "\t%s" "$arg"
    done
    exit 0
fi

# REMOTE EXECUTION
# ----------------
if [ $REMOTE_EXEC -ne 0 -a $FORCE_LOCAL_EXEC -eq 0 ]; then
    # Infer user name
    USR=$(whoami)
    case $USR in
        michi)
            REMOTE_USER=michele.caon
            ;;
        whasn)
            REMOTE_USER=walid.walid
            ;;
        *) # other
            log "WARNING: unknown user requested remote execution: expect errors."
            REMOTE_USER=$USR
            ;;
    esac

    # Copy source files to remote server
    log "Copying LEN5 source files to '%s'..." "$REMOTE_HOST"
    rsync -e "ssh $SSH_OPT" $RSYNC_OPT $LEN5_ROOT_DIR/./{include,src,tb,scripts,test-files} $REMOTE_USER@$REMOTE_HOST:$REMOTE_ROOT_DIR/
    [ $? -ne 0 ] && err "!!! ERROR while copying LEN5 source files..."

    # Pass options to remote script
    log "Launching script on remote server..."
    CMD_LINE="-L $CMD_LINE"
    remote_and_log "$REMOTE_ROOT_DIR/scripts/$(basename $0) $CMD_LINE"
    [ $? -ne 0 ] && err "!!! ERROR while executing remote script..."

    # Exit
    log "REMOTE EXECUTION COMPLETED!"
    exit 0
fi

# LOCAL EXECUTION
# ---------------

# Default Questa Sim initialization script
HOST_NAME=$(uname -n)
if [[ $HOST_NAME =~ .*.vlsilab ]]; then              # VLSI servers
    INIT_SCRIPT="/eda/scripts/init_questa"
elif [ $HOST_NAME = "localhost.localdomain" ]; then  # Microelectronic Systems server
    INIT_SCRIPT="/software/scripts/init_questa10.7c"
elif [ $HOST_NAME = "ghostpro" ]; then
    INIT_SCRIPT="$HOME/Documents/scripts/init-questa.sh"
else
    err "!!! WARNING: running on unsupported host. Expect some issues."
    INIT_SCRIPT=""
fi

# Initialize generated script
to_run_script "#!/bin/bash"
to_run_script "$HEADER_MSG"
to_run_script "$CMD_LINE_MSG"

# Get other arguments
if [ $# -gt 0 ]; then 
    CUSTOM_SRC=1
    INPUT_DIR=$1
    if [ $# -gt 1 ]; then
        TOP_MODULE_FILE=$2
        shift
    fi
    shift
fi
SIM_ARGS="$@"

# Create simulation directory
cd $LEN5_ROOT_DIR
to_run_script "cd $LEN5_ROOT_DIR"
mkdir -p "$SIM_DIR"
to_run_script "mkdir -p $(realpath --relative-to=$LEN5_ROOT_DIR $SIM_DIR)"

# Launch initialization script
log "Initializing QuestaSim..."
source "$INIT_SCRIPT"
[ $? -ne 0 ] && err "!!! ERROR while sourcing '%s'" "$INIT_SCRIPT"
to_run_script "source $INIT_SCRIPT"

# Compile files
# -------------

# Get a list of additional source files
if [ $CUSTOM_SRC -ne 0 ]; then
    REL_PATH=$(realpath --relative-to=$SIM_DIR $INPUT_DIR)
    SV_PKG_LIST=$(grep --include=\*.sv -rlE "^package \w+;" $INPUT_DIR | sed -e "s|$INPUT_DIR|$REL_PATH/|")
    SV_SRC_LIST=$(find $INPUT_DIR -type f -not -path '*/\.*' -not -name "*_pkg.sv" -and -name "*.sv" -or -name "*.v" | sed -e "s|$INPUT_DIR|$REL_PATH/|")

    # Save file list to file and add compilation flag
    > $COMPILE_OPT_FILE
    [ ! "$SV_PKG_LIST" = "" ] && echo "$SV_PKG_LIST" >> $COMPILE_OPT_FILE
    [ ! "$SV_SRC_LIST" = "" ] && echo "$SV_SRC_LIST" >> $COMPILE_OPT_FILE
    VLOG_ARGS="$VLOG_ARGS -F $COMPILE_OPT_FILE"
    export VLOG_ARGS=$VLOG_ARGS
    to_run_script "export VLOG_ARGS=\"$VLOG_ARGS\""
fi

# Export variables for make
export VLIB=$VLIB_PATH
export BUILD_DIR=$SIM_DIR

# Launch make
log "Compiling source files..."
run_and_log make $MAKE_OPT -C $LEN5_ROOT_DIR/scripts $BUILD_TARGET
[ $? -ne 0 ] && err "!!! ERROR while executing 'make'"
to_run_script "make $MAKE_OPT -C $LEN5_ROOT_DIR/scripts $BUILD_TARGET"

# Exit if only compilation was requested
log "COMPILATION SUCCESSFULLY COMPLETED!"
log
if [ $COMPILE_ONLY -ne 0 ]; then
    clean_up
    exit 0
fi

# Launch simulation 
# -----------------

# Get the module name
TOP_MODULE="$(basename $TOP_MODULE_FILE)"
TOP_MODULE=${TOP_MODULE%.*}

# Run the simulation
log "Launching simulation of top module '%s'..." "$TOP_MODULE"

# Assemble the simulation script
log "- assembling simulation script '%s'..." "${SIM_MACRO}"
if [ $VSIM_GUI -ne 0 ]; then 
    SIM_OPT="-gui $SIM_OPT"
    VSIM_DISABLE_OPT=1
else 
    SIM_OPT="-c $SIM_OPT"
fi
[ $VSIM_DISABLE_OPT -ne 0 ] && SIM_OPT="-voptargs=+acc $SIM_OPT"
if [ ! "$MEM_FILE" = "" ]; then
    MEM_FILE=$(realpath --relative-to=$SIM_DIR $MEM_FILE)
    SIM_OPT="$SIM_OPT +MEM_FILE=$MEM_FILE"
fi
SIM_OPT="$SIM_OPT +N=$NUM_CYCLES"
SIM_OPT="$SIM_OPT $SIM_ARGS"
if [ ! "$WAVE_FILE" = "" ]; then
    WAVE_FILE=$(realpath --relative-to=$SIM_DIR $WAVE_FILE)
    SIM_OPT="$SIM_OPT -do $WAVE_FILE"
fi
echo "$HEADER_MSG" > $SIM_MACRO
echo "\
puts \"\n########## SIMULATION STARTS ##########\n\"
run -all
puts \"\n##########  SIMULATION ENDS  ##########\n\"\
" >> $SIM_MACRO
[ ! $POST_SIM_SCRIPT = "" ] && echo "do $POST_SIM_SCRIPT" >> $SIM_MACRO
if [ $VSIM_GUI -eq 0 ]; then
    echo "exit" >> $SIM_MACRO
fi

# Prepare relative path
VLIB_PATH=$(realpath --relative-to $SIM_DIR $VLIB_PATH)
SIM_MACRO=$(realpath --relative-to $SIM_DIR $SIM_MACRO)

# Launch the simulation
log "- starting simulation..."
to_run_script "cd $SIM_DIR"
cd $SIM_DIR
run_and_log vsim -work $VLIB_PATH $SIM_OPT -do $SIM_MACRO ${TOP_MODULE}
if [ $? -ne 0 ]; then 
    err "!!! ERROR while simulating the design"
fi
cd $LEN5_ROOT_DIR
to_run_script "vsim -work $VLIB_PATH $SIM_OPT -do $SIM_MACRO ${TOP_MODULE}"
to_run_script "cd $LEN5_ROOT_DIR"

# Exit
log "### ALL DONE!"
clean_up
exit 0